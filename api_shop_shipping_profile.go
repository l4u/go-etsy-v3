/*
Etsy Open API v3

<div class=\"wt-text-body-01\"><p class=\"wt-pt-xs-2 wt-pb-xs-2\">Etsy's Open API provides a simple RESTful interface for various Etsy.com features. The API endpoints are meant to replace Etsy's Open API v2, which is scheduled to end service in 2022.</p><p class=\"wt-pb-xs-2\">All of the endpoints are callable and the majority of the API endpoints are now in a beta phase. This means we do not expect to make any breaking changes before our general release. A handful of endpoints are currently interface stubs (labeled “Feedback Only”) and returns a \"501 Not Implemented\" response code when called.</p><p class=\"wt-pb-xs-2\">If you'd like to report an issue or provide feedback on the API design, <a target=\"_blank\" class=\"wt-text-link wt-p-xs-0\" href=\"https://github.com/etsy/open-api/discussions\">please add an issue in Github</a>.</p></div>&copy; 2021-2023 Etsy, Inc. All Rights Reserved. Use of this code is subject to Etsy's <a class='wt-text-link wt-p-xs-0' target='_blank' href='https://www.etsy.com/legal/api'>API Developer Terms of Use</a>.

API version: 3.0.0
Contact: developers@etsy.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ShopShippingProfileApiService ShopShippingProfileApi service
type ShopShippingProfileApiService service

type ApiCreateShopShippingProfileRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	title *string
	originCountryIso *string
	primaryCost *float32
	secondaryCost *float32
	minProcessingTime *int32
	maxProcessingTime *int32
	processingTimeUnit *string
	destinationCountryIso *string
	destinationRegion *string
	originPostalCode *string
	shippingCarrierId *int32
	mailClass *string
	minDeliveryDays *int32
	maxDeliveryDays *int32
}

// The name string of this shipping profile.
func (r ApiCreateShopShippingProfileRequest) Title(title string) ApiCreateShopShippingProfileRequest {
	r.title = &title
	return r
}

// The ISO code of the country from which the listing ships.
func (r ApiCreateShopShippingProfileRequest) OriginCountryIso(originCountryIso string) ApiCreateShopShippingProfileRequest {
	r.originCountryIso = &originCountryIso
	return r
}

// The cost of shipping to this country/region alone, measured in the store&#39;s default currency.
func (r ApiCreateShopShippingProfileRequest) PrimaryCost(primaryCost float32) ApiCreateShopShippingProfileRequest {
	r.primaryCost = &primaryCost
	return r
}

// The cost of shipping to this country/region with another item, measured in the store&#39;s default currency.
func (r ApiCreateShopShippingProfileRequest) SecondaryCost(secondaryCost float32) ApiCreateShopShippingProfileRequest {
	r.secondaryCost = &secondaryCost
	return r
}

// The minimum time required to process to ship listings with this shipping profile.
func (r ApiCreateShopShippingProfileRequest) MinProcessingTime(minProcessingTime int32) ApiCreateShopShippingProfileRequest {
	r.minProcessingTime = &minProcessingTime
	return r
}

// The maximum processing time the listing needs to ship.
func (r ApiCreateShopShippingProfileRequest) MaxProcessingTime(maxProcessingTime int32) ApiCreateShopShippingProfileRequest {
	r.maxProcessingTime = &maxProcessingTime
	return r
}

// The unit used to represent how long a processing time is. A week is equivalent to 5 business days. If none is provided, the unit is set to \\\&quot;business_days\\\&quot;.
func (r ApiCreateShopShippingProfileRequest) ProcessingTimeUnit(processingTimeUnit string) ApiCreateShopShippingProfileRequest {
	r.processingTimeUnit = &processingTimeUnit
	return r
}

// The ISO code of the country to which the listing ships. If null, request sets destination to destination_region. Required if destination_region is null or not provided.
func (r ApiCreateShopShippingProfileRequest) DestinationCountryIso(destinationCountryIso string) ApiCreateShopShippingProfileRequest {
	r.destinationCountryIso = &destinationCountryIso
	return r
}

// The code of the region to which the listing ships. A region represents a set of countries. Supported regions are Europe Union and Non-Europe Union (countries in Europe not in EU). If &#x60;none&#x60;, request sets destination to destination_country_iso. Required if destination_country_iso is null or not provided.
func (r ApiCreateShopShippingProfileRequest) DestinationRegion(destinationRegion string) ApiCreateShopShippingProfileRequest {
	r.destinationRegion = &destinationRegion
	return r
}

// The postal code string (not necessarily a number) for the location from which the listing ships. Required if the &#x60;origin_country_iso&#x60; is &#x60;US&#x60; or &#x60;CA&#x60;.
func (r ApiCreateShopShippingProfileRequest) OriginPostalCode(originPostalCode string) ApiCreateShopShippingProfileRequest {
	r.originPostalCode = &originPostalCode
	return r
}

// The unique ID of a supported shipping carrier, which is used to calculate an Estimated Delivery Date. **Required with &#x60;mail_class&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileRequest) ShippingCarrierId(shippingCarrierId int32) ApiCreateShopShippingProfileRequest {
	r.shippingCarrierId = &shippingCarrierId
	return r
}

// The unique ID string of a shipping carrier&#39;s mail class, which is used to calculate an estimated delivery date. **Required with &#x60;shipping_carrier_id&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileRequest) MailClass(mailClass string) ApiCreateShopShippingProfileRequest {
	r.mailClass = &mailClass
	return r
}

// The minimum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;max_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileRequest) MinDeliveryDays(minDeliveryDays int32) ApiCreateShopShippingProfileRequest {
	r.minDeliveryDays = &minDeliveryDays
	return r
}

// The maximum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;min_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileRequest) MaxDeliveryDays(maxDeliveryDays int32) ApiCreateShopShippingProfileRequest {
	r.maxDeliveryDays = &maxDeliveryDays
	return r
}

func (r ApiCreateShopShippingProfileRequest) Execute() (*ShopShippingProfile, *http.Response, error) {
	return r.ApiService.CreateShopShippingProfileExecute(r)
}

/*
CreateShopShippingProfile Method for CreateShopShippingProfile

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Creates a new ShippingProfile. You can pass a country iso code or a region when creating a ShippingProfile, but not both. Only one is required. You must pass either a shipping_carrier_id AND mail_class, or both min and max_delivery_days.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiCreateShopShippingProfileRequest
*/
func (a *ShopShippingProfileApiService) CreateShopShippingProfile(ctx context.Context, shopId int32) ApiCreateShopShippingProfileRequest {
	return ApiCreateShopShippingProfileRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopShippingProfile
func (a *ShopShippingProfileApiService) CreateShopShippingProfileExecute(r ApiCreateShopShippingProfileRequest) (*ShopShippingProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.CreateShopShippingProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.originCountryIso == nil {
		return localVarReturnValue, nil, reportError("originCountryIso is required and must be specified")
	}
	if r.primaryCost == nil {
		return localVarReturnValue, nil, reportError("primaryCost is required and must be specified")
	}
	if *r.primaryCost < 0 {
		return localVarReturnValue, nil, reportError("primaryCost must be greater than 0")
	}
	if r.secondaryCost == nil {
		return localVarReturnValue, nil, reportError("secondaryCost is required and must be specified")
	}
	if *r.secondaryCost < 0 {
		return localVarReturnValue, nil, reportError("secondaryCost must be greater than 0")
	}
	if r.minProcessingTime == nil {
		return localVarReturnValue, nil, reportError("minProcessingTime is required and must be specified")
	}
	if *r.minProcessingTime < 1 {
		return localVarReturnValue, nil, reportError("minProcessingTime must be greater than 1")
	}
	if *r.minProcessingTime > 10 {
		return localVarReturnValue, nil, reportError("minProcessingTime must be less than 10")
	}
	if r.maxProcessingTime == nil {
		return localVarReturnValue, nil, reportError("maxProcessingTime is required and must be specified")
	}
	if *r.maxProcessingTime < 1 {
		return localVarReturnValue, nil, reportError("maxProcessingTime must be greater than 1")
	}
	if *r.maxProcessingTime > 10 {
		return localVarReturnValue, nil, reportError("maxProcessingTime must be less than 10")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "origin_country_iso", r.originCountryIso, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "primary_cost", r.primaryCost, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "secondary_cost", r.secondaryCost, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "min_processing_time", r.minProcessingTime, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "max_processing_time", r.maxProcessingTime, "")
	if r.processingTimeUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_time_unit", r.processingTimeUnit, "")
	}
	if r.destinationCountryIso != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_country_iso", r.destinationCountryIso, "")
	}
	if r.destinationRegion != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_region", r.destinationRegion, "")
	}
	if r.originPostalCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origin_postal_code", r.originPostalCode, "")
	}
	if r.shippingCarrierId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_carrier_id", r.shippingCarrierId, "")
	}
	if r.mailClass != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mail_class", r.mailClass, "")
	}
	if r.minDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_delivery_days", r.minDeliveryDays, "")
	}
	if r.maxDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_delivery_days", r.maxDeliveryDays, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShopShippingProfileDestinationRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	primaryCost *float32
	secondaryCost *float32
	destinationCountryIso *string
	destinationRegion *string
	shippingCarrierId *int32
	mailClass *string
	minDeliveryDays *int32
	maxDeliveryDays *int32
}

// The cost of shipping to this country/region alone, measured in the store&#39;s default currency.
func (r ApiCreateShopShippingProfileDestinationRequest) PrimaryCost(primaryCost float32) ApiCreateShopShippingProfileDestinationRequest {
	r.primaryCost = &primaryCost
	return r
}

// The cost of shipping to this country/region with another item, measured in the store&#39;s default currency.
func (r ApiCreateShopShippingProfileDestinationRequest) SecondaryCost(secondaryCost float32) ApiCreateShopShippingProfileDestinationRequest {
	r.secondaryCost = &secondaryCost
	return r
}

// The ISO code of the country to which the listing ships. If null, request sets destination to destination_region. Required if destination_region is null or not provided.
func (r ApiCreateShopShippingProfileDestinationRequest) DestinationCountryIso(destinationCountryIso string) ApiCreateShopShippingProfileDestinationRequest {
	r.destinationCountryIso = &destinationCountryIso
	return r
}

// The code of the region to which the listing ships. A region represents a set of countries. Supported regions are Europe Union and Non-Europe Union (countries in Europe not in EU). If &#x60;none&#x60;, request sets destination to destination_country_iso. Required if destination_country_iso is null or not provided.
func (r ApiCreateShopShippingProfileDestinationRequest) DestinationRegion(destinationRegion string) ApiCreateShopShippingProfileDestinationRequest {
	r.destinationRegion = &destinationRegion
	return r
}

// The unique ID of a supported shipping carrier, which is used to calculate an Estimated Delivery Date. **Required with &#x60;mail_class&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileDestinationRequest) ShippingCarrierId(shippingCarrierId int32) ApiCreateShopShippingProfileDestinationRequest {
	r.shippingCarrierId = &shippingCarrierId
	return r
}

// The unique ID string of a shipping carrier&#39;s mail class, which is used to calculate an estimated delivery date. **Required with &#x60;shipping_carrier_id&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileDestinationRequest) MailClass(mailClass string) ApiCreateShopShippingProfileDestinationRequest {
	r.mailClass = &mailClass
	return r
}

// The minimum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;max_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileDestinationRequest) MinDeliveryDays(minDeliveryDays int32) ApiCreateShopShippingProfileDestinationRequest {
	r.minDeliveryDays = &minDeliveryDays
	return r
}

// The maximum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;min_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileDestinationRequest) MaxDeliveryDays(maxDeliveryDays int32) ApiCreateShopShippingProfileDestinationRequest {
	r.maxDeliveryDays = &maxDeliveryDays
	return r
}

func (r ApiCreateShopShippingProfileDestinationRequest) Execute() (*ShopShippingProfileDestination, *http.Response, error) {
	return r.ApiService.CreateShopShippingProfileDestinationExecute(r)
}

/*
CreateShopShippingProfileDestination Method for CreateShopShippingProfileDestination

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Creates a new shipping destination, which sets the shipping cost, carrier, and class for a destination in a [shipping profile](/documentation/reference/#tag/Shop-ShippingProfile). createShopShippingProfileDestination assigns costs using the currency of the associated shop. Set the destination using either `destination_country_iso` or `destination_region`; `destination_country_iso` and `destination_region` are mutually exclusive — set one or the other. Setting both triggers error 400. If the request sets neither `destination_country_iso` nor `destination_region`, the default destination is "everywhere". You must also either assign both a `shipping_carrier_id` AND `mail_class` or both `min_delivery_days` AND `max_delivery_days`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiCreateShopShippingProfileDestinationRequest
*/
func (a *ShopShippingProfileApiService) CreateShopShippingProfileDestination(ctx context.Context, shopId int32, shippingProfileId int32) ApiCreateShopShippingProfileDestinationRequest {
	return ApiCreateShopShippingProfileDestinationRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileDestination
func (a *ShopShippingProfileApiService) CreateShopShippingProfileDestinationExecute(r ApiCreateShopShippingProfileDestinationRequest) (*ShopShippingProfileDestination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileDestination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.CreateShopShippingProfileDestination")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/destinations"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.primaryCost == nil {
		return localVarReturnValue, nil, reportError("primaryCost is required and must be specified")
	}
	if *r.primaryCost < 0 {
		return localVarReturnValue, nil, reportError("primaryCost must be greater than 0")
	}
	if r.secondaryCost == nil {
		return localVarReturnValue, nil, reportError("secondaryCost is required and must be specified")
	}
	if *r.secondaryCost < 0 {
		return localVarReturnValue, nil, reportError("secondaryCost must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "primary_cost", r.primaryCost, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "secondary_cost", r.secondaryCost, "")
	if r.destinationCountryIso != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_country_iso", r.destinationCountryIso, "")
	}
	if r.destinationRegion != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_region", r.destinationRegion, "")
	}
	if r.shippingCarrierId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_carrier_id", r.shippingCarrierId, "")
	}
	if r.mailClass != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mail_class", r.mailClass, "")
	}
	if r.minDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_delivery_days", r.minDeliveryDays, "")
	}
	if r.maxDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_delivery_days", r.maxDeliveryDays, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShopShippingProfileUpgradeRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	type_ *string
	upgradeName *string
	price *float32
	secondaryPrice *float32
	shippingCarrierId *int32
	mailClass *string
	minDeliveryDays *int32
	maxDeliveryDays *int32
}

// The type of the shipping upgrade. Domestic (0) or international (1).
func (r ApiCreateShopShippingProfileUpgradeRequest) Type_(type_ string) ApiCreateShopShippingProfileUpgradeRequest {
	r.type_ = &type_
	return r
}

// Name for the shipping upgrade shown to shoppers at checkout, e.g. USPS Priority.
func (r ApiCreateShopShippingProfileUpgradeRequest) UpgradeName(upgradeName string) ApiCreateShopShippingProfileUpgradeRequest {
	r.upgradeName = &upgradeName
	return r
}

// Additional cost of adding the shipping upgrade.
func (r ApiCreateShopShippingProfileUpgradeRequest) Price(price float32) ApiCreateShopShippingProfileUpgradeRequest {
	r.price = &price
	return r
}

// Additional cost of adding the shipping upgrade for each additional item.
func (r ApiCreateShopShippingProfileUpgradeRequest) SecondaryPrice(secondaryPrice float32) ApiCreateShopShippingProfileUpgradeRequest {
	r.secondaryPrice = &secondaryPrice
	return r
}

// The unique ID of a supported shipping carrier, which is used to calculate an Estimated Delivery Date. **Required with &#x60;mail_class&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileUpgradeRequest) ShippingCarrierId(shippingCarrierId int32) ApiCreateShopShippingProfileUpgradeRequest {
	r.shippingCarrierId = &shippingCarrierId
	return r
}

// The unique ID string of a shipping carrier&#39;s mail class, which is used to calculate an estimated delivery date. **Required with &#x60;shipping_carrier_id&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiCreateShopShippingProfileUpgradeRequest) MailClass(mailClass string) ApiCreateShopShippingProfileUpgradeRequest {
	r.mailClass = &mailClass
	return r
}

// The minimum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;max_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileUpgradeRequest) MinDeliveryDays(minDeliveryDays int32) ApiCreateShopShippingProfileUpgradeRequest {
	r.minDeliveryDays = &minDeliveryDays
	return r
}

// The maximum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;min_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiCreateShopShippingProfileUpgradeRequest) MaxDeliveryDays(maxDeliveryDays int32) ApiCreateShopShippingProfileUpgradeRequest {
	r.maxDeliveryDays = &maxDeliveryDays
	return r
}

func (r ApiCreateShopShippingProfileUpgradeRequest) Execute() (*ShopShippingProfileUpgrade, *http.Response, error) {
	return r.ApiService.CreateShopShippingProfileUpgradeExecute(r)
}

/*
CreateShopShippingProfileUpgrade Method for CreateShopShippingProfileUpgrade

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Creates a new shipping profile upgrade, which can establish a price for a shipping option, such as an alternate carrier or faster delivery.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiCreateShopShippingProfileUpgradeRequest
*/
func (a *ShopShippingProfileApiService) CreateShopShippingProfileUpgrade(ctx context.Context, shopId int32, shippingProfileId int32) ApiCreateShopShippingProfileUpgradeRequest {
	return ApiCreateShopShippingProfileUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileUpgrade
func (a *ShopShippingProfileApiService) CreateShopShippingProfileUpgradeExecute(r ApiCreateShopShippingProfileUpgradeRequest) (*ShopShippingProfileUpgrade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileUpgrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.CreateShopShippingProfileUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/upgrades"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.upgradeName == nil {
		return localVarReturnValue, nil, reportError("upgradeName is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if *r.price < 0 {
		return localVarReturnValue, nil, reportError("price must be greater than 0")
	}
	if r.secondaryPrice == nil {
		return localVarReturnValue, nil, reportError("secondaryPrice is required and must be specified")
	}
	if *r.secondaryPrice < 0 {
		return localVarReturnValue, nil, reportError("secondaryPrice must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "upgrade_name", r.upgradeName, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "secondary_price", r.secondaryPrice, "")
	if r.shippingCarrierId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_carrier_id", r.shippingCarrierId, "")
	}
	if r.mailClass != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mail_class", r.mailClass, "")
	}
	if r.minDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_delivery_days", r.minDeliveryDays, "")
	}
	if r.maxDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_delivery_days", r.maxDeliveryDays, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteShopShippingProfileRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
}

func (r ApiDeleteShopShippingProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShopShippingProfileExecute(r)
}

/*
DeleteShopShippingProfile Method for DeleteShopShippingProfile

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Deletes a ShippingProfile by given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiDeleteShopShippingProfileRequest
*/
func (a *ShopShippingProfileApiService) DeleteShopShippingProfile(ctx context.Context, shopId int32, shippingProfileId int32) ApiDeleteShopShippingProfileRequest {
	return ApiDeleteShopShippingProfileRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
func (a *ShopShippingProfileApiService) DeleteShopShippingProfileExecute(r ApiDeleteShopShippingProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.DeleteShopShippingProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return nil, reportError("shippingProfileId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteShopShippingProfileDestinationRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	shippingProfileDestinationId int32
}

func (r ApiDeleteShopShippingProfileDestinationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShopShippingProfileDestinationExecute(r)
}

/*
DeleteShopShippingProfileDestination Method for DeleteShopShippingProfileDestination

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Deletes a shipping destination and removes the destination option from every listing that uses the associated shipping profile. A shipping profile requires at least one shipping destination, so this endpoint cannot delete the final shipping destination for any shipping profile. To delete the final shipping destination from a shipping profile, you must [delete the entire shipping profile](/documentation/reference/#operation/deleteShopShippingProfile).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @param shippingProfileDestinationId The numeric ID of the shipping profile destination in the [shipping profile](/documentation/reference#tag/Shop-ShippingProfile) associated with the listing.
 @return ApiDeleteShopShippingProfileDestinationRequest
*/
func (a *ShopShippingProfileApiService) DeleteShopShippingProfileDestination(ctx context.Context, shopId int32, shippingProfileId int32, shippingProfileDestinationId int32) ApiDeleteShopShippingProfileDestinationRequest {
	return ApiDeleteShopShippingProfileDestinationRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
		shippingProfileDestinationId: shippingProfileDestinationId,
	}
}

// Execute executes the request
func (a *ShopShippingProfileApiService) DeleteShopShippingProfileDestinationExecute(r ApiDeleteShopShippingProfileDestinationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.DeleteShopShippingProfileDestination")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/destinations/{shipping_profile_destination_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_destination_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileDestinationId, "shippingProfileDestinationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.shippingProfileDestinationId < 1 {
		return nil, reportError("shippingProfileDestinationId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteShopShippingProfileUpgradeRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	upgradeId int32
}

func (r ApiDeleteShopShippingProfileUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShopShippingProfileUpgradeExecute(r)
}

/*
DeleteShopShippingProfileUpgrade Method for DeleteShopShippingProfileUpgrade

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Deletes a shipping profile upgrade and removes the upgrade option from every listing that uses the associated shipping profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the shipping profile.
 @param upgradeId The numeric ID that is associated with a shipping upgrade
 @return ApiDeleteShopShippingProfileUpgradeRequest
*/
func (a *ShopShippingProfileApiService) DeleteShopShippingProfileUpgrade(ctx context.Context, shopId int32, shippingProfileId int32, upgradeId int32) ApiDeleteShopShippingProfileUpgradeRequest {
	return ApiDeleteShopShippingProfileUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
		upgradeId: upgradeId,
	}
}

// Execute executes the request
func (a *ShopShippingProfileApiService) DeleteShopShippingProfileUpgradeExecute(r ApiDeleteShopShippingProfileUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.DeleteShopShippingProfileUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/upgrades/{upgrade_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upgrade_id"+"}", url.PathEscape(parameterValueToString(r.upgradeId, "upgradeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.upgradeId < 1 {
		return nil, reportError("upgradeId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetShippingCarriersRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	originCountryIso *string
}

// The ISO code of the country from which the listing ships.
func (r ApiGetShippingCarriersRequest) OriginCountryIso(originCountryIso string) ApiGetShippingCarriersRequest {
	r.originCountryIso = &originCountryIso
	return r
}

func (r ApiGetShippingCarriersRequest) Execute() (*ShippingCarriers, *http.Response, error) {
	return r.ApiService.GetShippingCarriersExecute(r)
}

/*
GetShippingCarriers Method for GetShippingCarriers

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a list of available shipping carriers and the mail classes associated with them for a given country

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetShippingCarriersRequest
*/
func (a *ShopShippingProfileApiService) GetShippingCarriers(ctx context.Context) ApiGetShippingCarriersRequest {
	return ApiGetShippingCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShippingCarriers
func (a *ShopShippingProfileApiService) GetShippingCarriersExecute(r ApiGetShippingCarriersRequest) (*ShippingCarriers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShippingCarriers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.GetShippingCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shipping-carriers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originCountryIso == nil {
		return localVarReturnValue, nil, reportError("originCountryIso is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "origin_country_iso", r.originCountryIso, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShopShippingProfileRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
}

func (r ApiGetShopShippingProfileRequest) Execute() (*ShopShippingProfile, *http.Response, error) {
	return r.ApiService.GetShopShippingProfileExecute(r)
}

/*
GetShopShippingProfile Method for GetShopShippingProfile

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a Shipping Profile referenced by shipping profile ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiGetShopShippingProfileRequest
*/
func (a *ShopShippingProfileApiService) GetShopShippingProfile(ctx context.Context, shopId int32, shippingProfileId int32) ApiGetShopShippingProfileRequest {
	return ApiGetShopShippingProfileRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfile
func (a *ShopShippingProfileApiService) GetShopShippingProfileExecute(r ApiGetShopShippingProfileRequest) (*ShopShippingProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.GetShopShippingProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShopShippingProfileDestinationsByShippingProfileRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	limit *int32
	offset *int32
}

// The maximum number of results to return.
func (r ApiGetShopShippingProfileDestinationsByShippingProfileRequest) Limit(limit int32) ApiGetShopShippingProfileDestinationsByShippingProfileRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiGetShopShippingProfileDestinationsByShippingProfileRequest) Offset(offset int32) ApiGetShopShippingProfileDestinationsByShippingProfileRequest {
	r.offset = &offset
	return r
}

func (r ApiGetShopShippingProfileDestinationsByShippingProfileRequest) Execute() (*ShopShippingProfileDestinations, *http.Response, error) {
	return r.ApiService.GetShopShippingProfileDestinationsByShippingProfileExecute(r)
}

/*
GetShopShippingProfileDestinationsByShippingProfile Method for GetShopShippingProfileDestinationsByShippingProfile

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a list of shipping destination objects associated with a shipping profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiGetShopShippingProfileDestinationsByShippingProfileRequest
*/
func (a *ShopShippingProfileApiService) GetShopShippingProfileDestinationsByShippingProfile(ctx context.Context, shopId int32, shippingProfileId int32) ApiGetShopShippingProfileDestinationsByShippingProfileRequest {
	return ApiGetShopShippingProfileDestinationsByShippingProfileRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileDestinations
func (a *ShopShippingProfileApiService) GetShopShippingProfileDestinationsByShippingProfileExecute(r ApiGetShopShippingProfileDestinationsByShippingProfileRequest) (*ShopShippingProfileDestinations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileDestinations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.GetShopShippingProfileDestinationsByShippingProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/destinations"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShopShippingProfileUpgradesRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
}

func (r ApiGetShopShippingProfileUpgradesRequest) Execute() (*ShopShippingProfileUpgrades, *http.Response, error) {
	return r.ApiService.GetShopShippingProfileUpgradesExecute(r)
}

/*
GetShopShippingProfileUpgrades Method for GetShopShippingProfileUpgrades

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves the list of shipping profile upgrades assigned to a specific shipping profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiGetShopShippingProfileUpgradesRequest
*/
func (a *ShopShippingProfileApiService) GetShopShippingProfileUpgrades(ctx context.Context, shopId int32, shippingProfileId int32) ApiGetShopShippingProfileUpgradesRequest {
	return ApiGetShopShippingProfileUpgradesRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileUpgrades
func (a *ShopShippingProfileApiService) GetShopShippingProfileUpgradesExecute(r ApiGetShopShippingProfileUpgradesRequest) (*ShopShippingProfileUpgrades, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileUpgrades
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.GetShopShippingProfileUpgrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/upgrades"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShopShippingProfilesRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
}

func (r ApiGetShopShippingProfilesRequest) Execute() (*ShopShippingProfiles, *http.Response, error) {
	return r.ApiService.GetShopShippingProfilesExecute(r)
}

/*
GetShopShippingProfiles Method for GetShopShippingProfiles

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a list of shipping profiles available in the specific Etsy shop identified by its shop ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetShopShippingProfilesRequest
*/
func (a *ShopShippingProfileApiService) GetShopShippingProfiles(ctx context.Context, shopId int32) ApiGetShopShippingProfilesRequest {
	return ApiGetShopShippingProfilesRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopShippingProfiles
func (a *ShopShippingProfileApiService) GetShopShippingProfilesExecute(r ApiGetShopShippingProfilesRequest) (*ShopShippingProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.GetShopShippingProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShopShippingProfileRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	title *string
	originCountryIso *string
	minProcessingTime *int32
	maxProcessingTime *int32
	processingTimeUnit *string
	originPostalCode *string
}

// The name string of this shipping profile.
func (r ApiUpdateShopShippingProfileRequest) Title(title string) ApiUpdateShopShippingProfileRequest {
	r.title = &title
	return r
}

// The ISO code of the country from which the listing ships.
func (r ApiUpdateShopShippingProfileRequest) OriginCountryIso(originCountryIso string) ApiUpdateShopShippingProfileRequest {
	r.originCountryIso = &originCountryIso
	return r
}

// The minimum time required to process to ship listings with this shipping profile.
func (r ApiUpdateShopShippingProfileRequest) MinProcessingTime(minProcessingTime int32) ApiUpdateShopShippingProfileRequest {
	r.minProcessingTime = &minProcessingTime
	return r
}

// The maximum processing time the listing needs to ship.
func (r ApiUpdateShopShippingProfileRequest) MaxProcessingTime(maxProcessingTime int32) ApiUpdateShopShippingProfileRequest {
	r.maxProcessingTime = &maxProcessingTime
	return r
}

// The unit used to represent how long a processing time is. A week is equivalent to 5 business days. If none is provided, the unit is set to \\\&quot;business_days\\\&quot;.
func (r ApiUpdateShopShippingProfileRequest) ProcessingTimeUnit(processingTimeUnit string) ApiUpdateShopShippingProfileRequest {
	r.processingTimeUnit = &processingTimeUnit
	return r
}

// The postal code string (not necessarily a number) for the location from which the listing ships. Required if the &#x60;origin_country_iso&#x60; is &#x60;US&#x60; or &#x60;CA&#x60;.
func (r ApiUpdateShopShippingProfileRequest) OriginPostalCode(originPostalCode string) ApiUpdateShopShippingProfileRequest {
	r.originPostalCode = &originPostalCode
	return r
}

func (r ApiUpdateShopShippingProfileRequest) Execute() (*ShopShippingProfile, *http.Response, error) {
	return r.ApiService.UpdateShopShippingProfileExecute(r)
}

/*
UpdateShopShippingProfile Method for UpdateShopShippingProfile

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Changes the settings in a shipping profile. You can pass a country iso code or a region when updating a ShippingProfile, but not both. Only one is required. You must pass either a shipping_carrier_id AND mail_class, or both min and max_delivery_days.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @return ApiUpdateShopShippingProfileRequest
*/
func (a *ShopShippingProfileApiService) UpdateShopShippingProfile(ctx context.Context, shopId int32, shippingProfileId int32) ApiUpdateShopShippingProfileRequest {
	return ApiUpdateShopShippingProfileRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
	}
}

// Execute executes the request
//  @return ShopShippingProfile
func (a *ShopShippingProfileApiService) UpdateShopShippingProfileExecute(r ApiUpdateShopShippingProfileRequest) (*ShopShippingProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.UpdateShopShippingProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	}
	if r.originCountryIso != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origin_country_iso", r.originCountryIso, "")
	}
	if r.minProcessingTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_processing_time", r.minProcessingTime, "")
	}
	if r.maxProcessingTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_processing_time", r.maxProcessingTime, "")
	}
	if r.processingTimeUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_time_unit", r.processingTimeUnit, "")
	}
	if r.originPostalCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origin_postal_code", r.originPostalCode, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShopShippingProfileDestinationRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	shippingProfileDestinationId int32
	primaryCost *float32
	secondaryCost *float32
	destinationCountryIso *string
	destinationRegion *string
	shippingCarrierId *int32
	mailClass *string
	minDeliveryDays *int32
	maxDeliveryDays *int32
}

// The cost of shipping to this country/region alone, measured in the store&#39;s default currency.
func (r ApiUpdateShopShippingProfileDestinationRequest) PrimaryCost(primaryCost float32) ApiUpdateShopShippingProfileDestinationRequest {
	r.primaryCost = &primaryCost
	return r
}

// The cost of shipping to this country/region with another item, measured in the store&#39;s default currency.
func (r ApiUpdateShopShippingProfileDestinationRequest) SecondaryCost(secondaryCost float32) ApiUpdateShopShippingProfileDestinationRequest {
	r.secondaryCost = &secondaryCost
	return r
}

// The ISO code of the country to which the listing ships. If null, request sets destination to destination_region. Required if destination_region is null or not provided.
func (r ApiUpdateShopShippingProfileDestinationRequest) DestinationCountryIso(destinationCountryIso string) ApiUpdateShopShippingProfileDestinationRequest {
	r.destinationCountryIso = &destinationCountryIso
	return r
}

// The code of the region to which the listing ships. A region represents a set of countries. Supported regions are Europe Union and Non-Europe Union (countries in Europe not in EU). If &#x60;none&#x60;, request sets destination to destination_country_iso. Required if destination_country_iso is null or not provided.
func (r ApiUpdateShopShippingProfileDestinationRequest) DestinationRegion(destinationRegion string) ApiUpdateShopShippingProfileDestinationRequest {
	r.destinationRegion = &destinationRegion
	return r
}

// The unique ID of a supported shipping carrier, which is used to calculate an Estimated Delivery Date. **Required with &#x60;mail_class&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiUpdateShopShippingProfileDestinationRequest) ShippingCarrierId(shippingCarrierId int32) ApiUpdateShopShippingProfileDestinationRequest {
	r.shippingCarrierId = &shippingCarrierId
	return r
}

// The unique ID string of a shipping carrier&#39;s mail class, which is used to calculate an estimated delivery date. **Required with &#x60;shipping_carrier_id&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiUpdateShopShippingProfileDestinationRequest) MailClass(mailClass string) ApiUpdateShopShippingProfileDestinationRequest {
	r.mailClass = &mailClass
	return r
}

// The minimum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;max_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiUpdateShopShippingProfileDestinationRequest) MinDeliveryDays(minDeliveryDays int32) ApiUpdateShopShippingProfileDestinationRequest {
	r.minDeliveryDays = &minDeliveryDays
	return r
}

// The maximum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;min_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiUpdateShopShippingProfileDestinationRequest) MaxDeliveryDays(maxDeliveryDays int32) ApiUpdateShopShippingProfileDestinationRequest {
	r.maxDeliveryDays = &maxDeliveryDays
	return r
}

func (r ApiUpdateShopShippingProfileDestinationRequest) Execute() (*ShopShippingProfileDestination, *http.Response, error) {
	return r.ApiService.UpdateShopShippingProfileDestinationExecute(r)
}

/*
UpdateShopShippingProfileDestination Method for UpdateShopShippingProfileDestination

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates an existing shipping destination, which can set or reassign the shipping cost, carrier, and class for a destination.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @param shippingProfileDestinationId The numeric ID of the shipping profile destination in the [shipping profile](/documentation/reference#tag/Shop-ShippingProfile) associated with the listing.
 @return ApiUpdateShopShippingProfileDestinationRequest
*/
func (a *ShopShippingProfileApiService) UpdateShopShippingProfileDestination(ctx context.Context, shopId int32, shippingProfileId int32, shippingProfileDestinationId int32) ApiUpdateShopShippingProfileDestinationRequest {
	return ApiUpdateShopShippingProfileDestinationRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
		shippingProfileDestinationId: shippingProfileDestinationId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileDestination
func (a *ShopShippingProfileApiService) UpdateShopShippingProfileDestinationExecute(r ApiUpdateShopShippingProfileDestinationRequest) (*ShopShippingProfileDestination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileDestination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.UpdateShopShippingProfileDestination")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/destinations/{shipping_profile_destination_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_destination_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileDestinationId, "shippingProfileDestinationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.shippingProfileDestinationId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileDestinationId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.primaryCost != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "primary_cost", r.primaryCost, "")
	}
	if r.secondaryCost != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "secondary_cost", r.secondaryCost, "")
	}
	if r.destinationCountryIso != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_country_iso", r.destinationCountryIso, "")
	}
	if r.destinationRegion != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination_region", r.destinationRegion, "")
	}
	if r.shippingCarrierId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_carrier_id", r.shippingCarrierId, "")
	}
	if r.mailClass != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mail_class", r.mailClass, "")
	}
	if r.minDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_delivery_days", r.minDeliveryDays, "")
	}
	if r.maxDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_delivery_days", r.maxDeliveryDays, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShopShippingProfileUpgradeRequest struct {
	ctx context.Context
	ApiService *ShopShippingProfileApiService
	shopId int32
	shippingProfileId int32
	upgradeId int32
	upgradeName *string
	type_ *string
	price *float32
	secondaryPrice *float32
	shippingCarrierId *int32
	mailClass *string
	minDeliveryDays *int32
	maxDeliveryDays *int32
}

// Name for the shipping upgrade shown to shoppers at checkout, e.g. USPS Priority.
func (r ApiUpdateShopShippingProfileUpgradeRequest) UpgradeName(upgradeName string) ApiUpdateShopShippingProfileUpgradeRequest {
	r.upgradeName = &upgradeName
	return r
}

// The type of the shipping upgrade. Domestic (0) or international (1).
func (r ApiUpdateShopShippingProfileUpgradeRequest) Type_(type_ string) ApiUpdateShopShippingProfileUpgradeRequest {
	r.type_ = &type_
	return r
}

// Additional cost of adding the shipping upgrade.
func (r ApiUpdateShopShippingProfileUpgradeRequest) Price(price float32) ApiUpdateShopShippingProfileUpgradeRequest {
	r.price = &price
	return r
}

// Additional cost of adding the shipping upgrade for each additional item.
func (r ApiUpdateShopShippingProfileUpgradeRequest) SecondaryPrice(secondaryPrice float32) ApiUpdateShopShippingProfileUpgradeRequest {
	r.secondaryPrice = &secondaryPrice
	return r
}

// The unique ID of a supported shipping carrier, which is used to calculate an Estimated Delivery Date. **Required with &#x60;mail_class&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiUpdateShopShippingProfileUpgradeRequest) ShippingCarrierId(shippingCarrierId int32) ApiUpdateShopShippingProfileUpgradeRequest {
	r.shippingCarrierId = &shippingCarrierId
	return r
}

// The unique ID string of a shipping carrier&#39;s mail class, which is used to calculate an estimated delivery date. **Required with &#x60;shipping_carrier_id&#x60;** if &#x60;min_delivery_days&#x60; and &#x60;max_delivery_days&#x60; are null.
func (r ApiUpdateShopShippingProfileUpgradeRequest) MailClass(mailClass string) ApiUpdateShopShippingProfileUpgradeRequest {
	r.mailClass = &mailClass
	return r
}

// The minimum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;max_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiUpdateShopShippingProfileUpgradeRequest) MinDeliveryDays(minDeliveryDays int32) ApiUpdateShopShippingProfileUpgradeRequest {
	r.minDeliveryDays = &minDeliveryDays
	return r
}

// The maximum number of business days a buyer can expect to wait to receive their purchased item once it has shipped. **Required with &#x60;min_delivery_days&#x60;** if &#x60;mail_class&#x60; is null.
func (r ApiUpdateShopShippingProfileUpgradeRequest) MaxDeliveryDays(maxDeliveryDays int32) ApiUpdateShopShippingProfileUpgradeRequest {
	r.maxDeliveryDays = &maxDeliveryDays
	return r
}

func (r ApiUpdateShopShippingProfileUpgradeRequest) Execute() (*ShopShippingProfileUpgrade, *http.Response, error) {
	return r.ApiService.UpdateShopShippingProfileUpgradeExecute(r)
}

/*
UpdateShopShippingProfileUpgrade Method for UpdateShopShippingProfileUpgrade

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates a shipping profile upgrade and updates any listings that use the shipping profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param shippingProfileId The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is `physical`.
 @param upgradeId The numeric ID that is associated with a shipping upgrade
 @return ApiUpdateShopShippingProfileUpgradeRequest
*/
func (a *ShopShippingProfileApiService) UpdateShopShippingProfileUpgrade(ctx context.Context, shopId int32, shippingProfileId int32, upgradeId int32) ApiUpdateShopShippingProfileUpgradeRequest {
	return ApiUpdateShopShippingProfileUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		shippingProfileId: shippingProfileId,
		upgradeId: upgradeId,
	}
}

// Execute executes the request
//  @return ShopShippingProfileUpgrade
func (a *ShopShippingProfileApiService) UpdateShopShippingProfileUpgradeExecute(r ApiUpdateShopShippingProfileUpgradeRequest) (*ShopShippingProfileUpgrade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopShippingProfileUpgrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopShippingProfileApiService.UpdateShopShippingProfileUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shipping-profiles/{shipping_profile_id}/upgrades/{upgrade_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipping_profile_id"+"}", url.PathEscape(parameterValueToString(r.shippingProfileId, "shippingProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upgrade_id"+"}", url.PathEscape(parameterValueToString(r.upgradeId, "upgradeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shippingProfileId < 1 {
		return localVarReturnValue, nil, reportError("shippingProfileId must be greater than 1")
	}
	if r.upgradeId < 1 {
		return localVarReturnValue, nil, reportError("upgradeId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.upgradeName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upgrade_name", r.upgradeName, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "")
	}
	if r.secondaryPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "secondary_price", r.secondaryPrice, "")
	}
	if r.shippingCarrierId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_carrier_id", r.shippingCarrierId, "")
	}
	if r.mailClass != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mail_class", r.mailClass, "")
	}
	if r.minDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "min_delivery_days", r.minDeliveryDays, "")
	}
	if r.maxDeliveryDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_delivery_days", r.maxDeliveryDays, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
