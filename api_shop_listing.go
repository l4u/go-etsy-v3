/*
Etsy Open API v3

<div class=\"wt-text-body-01\"><p class=\"wt-pt-xs-2 wt-pb-xs-2\">Etsy's Open API provides a simple RESTful interface for various Etsy.com features. The API endpoints are meant to replace Etsy's Open API v2, which is scheduled to end service in 2022.</p><p class=\"wt-pb-xs-2\">All of the endpoints are callable and the majority of the API endpoints are now in a beta phase. This means we do not expect to make any breaking changes before our general release. A handful of endpoints are currently interface stubs (labeled “Feedback Only”) and returns a \"501 Not Implemented\" response code when called.</p><p class=\"wt-pb-xs-2\">If you'd like to report an issue or provide feedback on the API design, <a target=\"_blank\" class=\"wt-text-link wt-p-xs-0\" href=\"https://github.com/etsy/open-api/discussions\">please add an issue in Github</a>.</p></div>&copy; 2021-2023 Etsy, Inc. All Rights Reserved. Use of this code is subject to Etsy's <a class='wt-text-link wt-p-xs-0' target='_blank' href='https://www.etsy.com/legal/api'>API Developer Terms of Use</a>.

API version: 3.0.0
Contact: developers@etsy.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ShopListingApiService ShopListingApi service
type ShopListingApiService service

type ApiCreateDraftListingRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	quantity *int32
	title *string
	description *string
	price *float32
	whoMade *string
	whenMade *string
	taxonomyId *int32
	shippingProfileId *int32
	returnPolicyId *int32
	materials *[]string
	shopSectionId *int32
	processingMin *int32
	processingMax *int32
	tags *[]string
	styles *[]string
	itemWeight *float32
	itemLength *float32
	itemWidth *float32
	itemHeight *float32
	itemWeightUnit *string
	itemDimensionsUnit *string
	isPersonalizable *bool
	personalizationIsRequired *bool
	personalizationCharCountMax *int32
	personalizationInstructions *string
	productionPartnerIds *[]int32
	imageIds *[]int32
	isSupply *bool
	isCustomizable *bool
	shouldAutoRenew *bool
	isTaxable *bool
	type_ *string
}

// The positive non-zero number of products available for purchase in the listing. Note: The listing quantity is the sum of available offering quantities. You can request the quantities for individual offerings from the ListingInventory resource using the [getListingInventory](/documentation/reference#operation/getListingInventory) endpoint.
func (r ApiCreateDraftListingRequest) Quantity(quantity int32) ApiCreateDraftListingRequest {
	r.quantity = &quantity
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ApiCreateDraftListingRequest) Title(title string) ApiCreateDraftListingRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ApiCreateDraftListingRequest) Description(description string) ApiCreateDraftListingRequest {
	r.description = &description
	return r
}

// The positive non-zero price of the product. (Sold product listings are private) Note: The price is the minimum possible price. The [&#x60;getListingInventory&#x60;](/documentation/reference/#operation/getListingInventory) method requests exact prices for available offerings.
func (r ApiCreateDraftListingRequest) Price(price float32) ApiCreateDraftListingRequest {
	r.price = &price
	return r
}

// An enumerated string indicating who made the product. Helps buyers locate the listing under the Handmade heading. Requires &#39;is_supply&#39; and &#39;when_made&#39;.
func (r ApiCreateDraftListingRequest) WhoMade(whoMade string) ApiCreateDraftListingRequest {
	r.whoMade = &whoMade
	return r
}

// An enumerated string for the era in which the maker made the product in this listing. Helps buyers locate the listing under the Vintage heading. Requires &#39;is_supply&#39; and &#39;who_made&#39;.
func (r ApiCreateDraftListingRequest) WhenMade(whenMade string) ApiCreateDraftListingRequest {
	r.whenMade = &whenMade
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ApiCreateDraftListingRequest) TaxonomyId(taxonomyId int32) ApiCreateDraftListingRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ApiCreateDraftListingRequest) ShippingProfileId(shippingProfileId int32) ApiCreateDraftListingRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies).
func (r ApiCreateDraftListingRequest) ReturnPolicyId(returnPolicyId int32) ApiCreateDraftListingRequest {
	r.returnPolicyId = &returnPolicyId
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ApiCreateDraftListingRequest) Materials(materials []string) ApiCreateDraftListingRequest {
	r.materials = &materials
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ApiCreateDraftListingRequest) ShopSectionId(shopSectionId int32) ApiCreateDraftListingRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The minimum number of days required to process this listing. Default value is null.
func (r ApiCreateDraftListingRequest) ProcessingMin(processingMin int32) ApiCreateDraftListingRequest {
	r.processingMin = &processingMin
	return r
}

// The maximum number of days required to process this listing. Default value is null.
func (r ApiCreateDraftListingRequest) ProcessingMax(processingMax int32) ApiCreateDraftListingRequest {
	r.processingMax = &processingMax
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ApiCreateDraftListingRequest) Tags(tags []string) ApiCreateDraftListingRequest {
	r.tags = &tags
	return r
}

// An array of style strings for this listing, each of which is free-form text string such as \\\&quot;Formal\\\&quot;, or \\\&quot;Steampunk\\\&quot;. When creating or updating a listing, the listing may have up to two styles. Valid style strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ApiCreateDraftListingRequest) Styles(styles []string) ApiCreateDraftListingRequest {
	r.styles = &styles
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiCreateDraftListingRequest) ItemWeight(itemWeight float32) ApiCreateDraftListingRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiCreateDraftListingRequest) ItemLength(itemLength float32) ApiCreateDraftListingRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiCreateDraftListingRequest) ItemWidth(itemWidth float32) ApiCreateDraftListingRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiCreateDraftListingRequest) ItemHeight(itemHeight float32) ApiCreateDraftListingRequest {
	r.itemHeight = &itemHeight
	return r
}

// A string defining the units used to measure the weight of the product. Default value is null.
func (r ApiCreateDraftListingRequest) ItemWeightUnit(itemWeightUnit string) ApiCreateDraftListingRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

// A string defining the units used to measure the dimensions of the product. Default value is null.
func (r ApiCreateDraftListingRequest) ItemDimensionsUnit(itemDimensionsUnit string) ApiCreateDraftListingRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ApiCreateDraftListingRequest) IsPersonalizable(isPersonalizable bool) ApiCreateDraftListingRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiCreateDraftListingRequest) PersonalizationIsRequired(personalizationIsRequired bool) ApiCreateDraftListingRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiCreateDraftListingRequest) PersonalizationCharCountMax(personalizationCharCountMax int32) ApiCreateDraftListingRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiCreateDraftListingRequest) PersonalizationInstructions(personalizationInstructions string) ApiCreateDraftListingRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

// An array of unique IDs of production partner ids.
func (r ApiCreateDraftListingRequest) ProductionPartnerIds(productionPartnerIds []int32) ApiCreateDraftListingRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ApiCreateDraftListingRequest) ImageIds(imageIds []int32) ApiCreateDraftListingRequest {
	r.imageIds = &imageIds
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ApiCreateDraftListingRequest) IsSupply(isSupply bool) ApiCreateDraftListingRequest {
	r.isSupply = &isSupply
	return r
}

// When true, a buyer may contact the seller for a customized order. The default value is true when a shop accepts custom orders. Does not apply to shops that do not accept custom orders.
func (r ApiCreateDraftListingRequest) IsCustomizable(isCustomizable bool) ApiCreateDraftListingRequest {
	r.isCustomizable = &isCustomizable
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ApiCreateDraftListingRequest) ShouldAutoRenew(shouldAutoRenew bool) ApiCreateDraftListingRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ApiCreateDraftListingRequest) IsTaxable(isTaxable bool) ApiCreateDraftListingRequest {
	r.isTaxable = &isTaxable
	return r
}

// An enumerated type string that indicates whether the listing is physical or a digital download.
func (r ApiCreateDraftListingRequest) Type_(type_ string) ApiCreateDraftListingRequest {
	r.type_ = &type_
	return r
}

func (r ApiCreateDraftListingRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.CreateDraftListingExecute(r)
}

/*
CreateDraftListing Method for CreateDraftListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Creates a physical draft [listing](/documentation/reference#tag/ShopListing) product in a shop on the Etsy channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiCreateDraftListingRequest
*/
func (a *ShopListingApiService) CreateDraftListing(ctx context.Context, shopId int32) ApiCreateDraftListingRequest {
	return ApiCreateDraftListingRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListing
func (a *ShopListingApiService) CreateDraftListingExecute(r ApiCreateDraftListingRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.CreateDraftListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.whoMade == nil {
		return localVarReturnValue, nil, reportError("whoMade is required and must be specified")
	}
	if r.whenMade == nil {
		return localVarReturnValue, nil, reportError("whenMade is required and must be specified")
	}
	if r.taxonomyId == nil {
		return localVarReturnValue, nil, reportError("taxonomyId is required and must be specified")
	}
	if *r.taxonomyId < 1 {
		return localVarReturnValue, nil, reportError("taxonomyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "")
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "")
	}
	if r.returnPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "return_policy_id", r.returnPolicyId, "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "csv")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "")
	}
	if r.processingMin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_min", r.processingMin, "")
	}
	if r.processingMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_max", r.processingMax, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "csv")
	}
	if r.styles != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "styles", r.styles, "csv")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "csv")
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "csv")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "")
	}
	if r.isCustomizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_customizable", r.isCustomizable, "")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteListingRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	listingId int32
}

func (r ApiDeleteListingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingExecute(r)
}

/*
DeleteListing Method for DeleteListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Open API V3 endpoint to delete a ShopListing. A ShopListing can be deleted only if the state is one of the following:  SOLD_OUT, DRAFT, EXPIRED, INACTIVE, ACTIVE and is_available or ACTIVE and has seller flags:  SUPRESSED (frozen), VACATION, CUSTOM_SHOPS (pattern), SELL_ON_FACEBOOK

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @return ApiDeleteListingRequest
*/
func (a *ShopListingApiService) DeleteListing(ctx context.Context, listingId int32) ApiDeleteListingRequest {
	return ApiDeleteListingRequest{
		ApiService: a,
		ctx: ctx,
		listingId: listingId,
	}
}

// Execute executes the request
func (a *ShopListingApiService) DeleteListingExecute(r ApiDeleteListingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.DeleteListing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListingPropertyRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	listingId int32
	propertyId int32
}

func (r ApiDeleteListingPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingPropertyExecute(r)
}

/*
DeleteListingProperty Method for DeleteListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Deletes a property for a Listing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
 @return ApiDeleteListingPropertyRequest
*/
func (a *ShopListingApiService) DeleteListingProperty(ctx context.Context, shopId int32, listingId int32, propertyId int32) ApiDeleteListingPropertyRequest {
	return ApiDeleteListingPropertyRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		listingId: listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ShopListingApiService) DeleteListingPropertyExecute(r ApiDeleteListingPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.DeleteListingProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return nil, reportError("propertyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindAllActiveListingsByShopRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	limit *int32
	sortOn *string
	sortOrder *string
	offset *int32
	keywords *string
}

// The maximum number of results to return.
func (r ApiFindAllActiveListingsByShopRequest) Limit(limit int32) ApiFindAllActiveListingsByShopRequest {
	r.limit = &limit
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ApiFindAllActiveListingsByShopRequest) SortOn(sortOn string) ApiFindAllActiveListingsByShopRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ApiFindAllActiveListingsByShopRequest) SortOrder(sortOrder string) ApiFindAllActiveListingsByShopRequest {
	r.sortOrder = &sortOrder
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiFindAllActiveListingsByShopRequest) Offset(offset int32) ApiFindAllActiveListingsByShopRequest {
	r.offset = &offset
	return r
}

// Search term or phrase that must appear in all results.
func (r ApiFindAllActiveListingsByShopRequest) Keywords(keywords string) ApiFindAllActiveListingsByShopRequest {
	r.keywords = &keywords
	return r
}

func (r ApiFindAllActiveListingsByShopRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.FindAllActiveListingsByShopExecute(r)
}

/*
FindAllActiveListingsByShop Method for FindAllActiveListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a list of all active listings on Etsy in a specific shop, paginated by listing creation date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiFindAllActiveListingsByShopRequest
*/
func (a *ShopListingApiService) FindAllActiveListingsByShop(ctx context.Context, shopId int32) ApiFindAllActiveListingsByShopRequest {
	return ApiFindAllActiveListingsByShopRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) FindAllActiveListingsByShopExecute(r ApiFindAllActiveListingsByShopRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.FindAllActiveListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/active"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindAllListingsActiveRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	limit *int32
	offset *int32
	keywords *string
	sortOn *string
	sortOrder *string
	minPrice *float32
	maxPrice *float32
	taxonomyId *int32
	shopLocation *string
}

// The maximum number of results to return.
func (r ApiFindAllListingsActiveRequest) Limit(limit int32) ApiFindAllListingsActiveRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiFindAllListingsActiveRequest) Offset(offset int32) ApiFindAllListingsActiveRequest {
	r.offset = &offset
	return r
}

// Search term or phrase that must appear in all results.
func (r ApiFindAllListingsActiveRequest) Keywords(keywords string) ApiFindAllListingsActiveRequest {
	r.keywords = &keywords
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ApiFindAllListingsActiveRequest) SortOn(sortOn string) ApiFindAllListingsActiveRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ApiFindAllListingsActiveRequest) SortOrder(sortOrder string) ApiFindAllListingsActiveRequest {
	r.sortOrder = &sortOrder
	return r
}

// The minimum price of listings to be returned by a search result.
func (r ApiFindAllListingsActiveRequest) MinPrice(minPrice float32) ApiFindAllListingsActiveRequest {
	r.minPrice = &minPrice
	return r
}

// The maximum price of listings to be returned by a search result.
func (r ApiFindAllListingsActiveRequest) MaxPrice(maxPrice float32) ApiFindAllListingsActiveRequest {
	r.maxPrice = &maxPrice
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ApiFindAllListingsActiveRequest) TaxonomyId(taxonomyId int32) ApiFindAllListingsActiveRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// Filters by shop location. If location cannot be parsed, Etsy responds with an error.
func (r ApiFindAllListingsActiveRequest) ShopLocation(shopLocation string) ApiFindAllListingsActiveRequest {
	r.shopLocation = &shopLocation
	return r
}

func (r ApiFindAllListingsActiveRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.FindAllListingsActiveExecute(r)
}

/*
FindAllListingsActive Method for FindAllListingsActive

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

A list of all active listings on Etsy paginated by their creation date. Without sort_order listings will be returned newest-first by default.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindAllListingsActiveRequest
*/
func (a *ShopListingApiService) FindAllListingsActive(ctx context.Context) ApiFindAllListingsActiveRequest {
	return ApiFindAllListingsActiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) FindAllListingsActiveExecute(r ApiFindAllListingsActiveRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.FindAllListingsActive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "")
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	}
	if r.minPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_price", r.minPrice, "")
	}
	if r.maxPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_price", r.maxPrice, "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxonomy_id", r.taxonomyId, "")
	}
	if r.shopLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_location", r.shopLocation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeaturedListingsByShopRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	limit *int32
	offset *int32
}

// The maximum number of results to return.
func (r ApiGetFeaturedListingsByShopRequest) Limit(limit int32) ApiGetFeaturedListingsByShopRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiGetFeaturedListingsByShopRequest) Offset(offset int32) ApiGetFeaturedListingsByShopRequest {
	r.offset = &offset
	return r
}

func (r ApiGetFeaturedListingsByShopRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetFeaturedListingsByShopExecute(r)
}

/*
GetFeaturedListingsByShop Method for GetFeaturedListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves Listings associated to a Shop that are featured.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetFeaturedListingsByShopRequest
*/
func (a *ShopListingApiService) GetFeaturedListingsByShop(ctx context.Context, shopId int32) ApiGetFeaturedListingsByShopRequest {
	return ApiGetFeaturedListingsByShopRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) GetFeaturedListingsByShopExecute(r ApiGetFeaturedListingsByShopRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetFeaturedListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/featured"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	listingId int32
	includes *[]string
	language *string
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ApiGetListingRequest) Includes(includes []string) ApiGetListingRequest {
	r.includes = &includes
	return r
}

// The IETF language tag for the language of this translation. Ex: &#x60;de&#x60;, &#x60;en&#x60;, &#x60;es&#x60;, &#x60;fr&#x60;, &#x60;it&#x60;, &#x60;ja&#x60;, &#x60;nl&#x60;, &#x60;pl&#x60;, &#x60;pt&#x60;.
func (r ApiGetListingRequest) Language(language string) ApiGetListingRequest {
	r.language = &language
	return r
}

func (r ApiGetListingRequest) Execute() (*ShopListingWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingExecute(r)
}

/*
GetListing Method for GetListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a listing record by listing ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @return ApiGetListingRequest
*/
func (a *ShopListingApiService) GetListing(ctx context.Context, listingId int32) ApiGetListingRequest {
	return ApiGetListingRequest{
		ApiService: a,
		ctx: ctx,
		listingId: listingId,
	}
}

// Execute executes the request
//  @return ShopListingWithAssociations
func (a *ShopListingApiService) GetListingExecute(r ApiGetListingRequest) (*ShopListingWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListingWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "multi")
		}
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingPropertiesRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	listingId int32
}

func (r ApiGetListingPropertiesRequest) Execute() (*ListingPropertyValues, *http.Response, error) {
	return r.ApiService.GetListingPropertiesExecute(r)
}

/*
GetListingProperties Method for GetListingProperties

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Get a listing's properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @return ApiGetListingPropertiesRequest
*/
func (a *ShopListingApiService) GetListingProperties(ctx context.Context, shopId int32, listingId int32) ApiGetListingPropertiesRequest {
	return ApiGetListingPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		listingId: listingId,
	}
}

// Execute executes the request
//  @return ListingPropertyValues
func (a *ShopListingApiService) GetListingPropertiesExecute(r ApiGetListingPropertiesRequest) (*ListingPropertyValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingPropertyValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingPropertyRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	listingId int32
	propertyId int32
}

func (r ApiGetListingPropertyRequest) Execute() (*ListingPropertyValue, *http.Response, error) {
	return r.ApiService.GetListingPropertyExecute(r)
}

/*
GetListingProperty Method for GetListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-01 wt-mr-xs-2"> Feedback only </span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Give feedback</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">Development for this endpoint is in progress. It will only return a 501 response.</p></div>

Retrieves a listing's property

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
 @return ApiGetListingPropertyRequest
*/
func (a *ShopListingApiService) GetListingProperty(ctx context.Context, listingId int32, propertyId int32) ApiGetListingPropertyRequest {
	return ApiGetListingPropertyRequest{
		ApiService: a,
		ctx: ctx,
		listingId: listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ListingPropertyValue
func (a *ShopListingApiService) GetListingPropertyExecute(r ApiGetListingPropertyRequest) (*ListingPropertyValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingPropertyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return localVarReturnValue, nil, reportError("propertyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingsByListingIdsRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	listingIds *[]int32
	includes *[]string
}

// The list of numeric IDS for the listings in a specific Etsy shop.
func (r ApiGetListingsByListingIdsRequest) ListingIds(listingIds []int32) ApiGetListingsByListingIdsRequest {
	r.listingIds = &listingIds
	return r
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ApiGetListingsByListingIdsRequest) Includes(includes []string) ApiGetListingsByListingIdsRequest {
	r.includes = &includes
	return r
}

func (r ApiGetListingsByListingIdsRequest) Execute() (*ShopListingsWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingsByListingIdsExecute(r)
}

/*
GetListingsByListingIds Method for GetListingsByListingIds

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Allows to query multiple listing ids at once. Limit 100 ids maximum per query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListingsByListingIdsRequest
*/
func (a *ShopListingApiService) GetListingsByListingIds(ctx context.Context) ApiGetListingsByListingIdsRequest {
	return ApiGetListingsByListingIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShopListingsWithAssociations
func (a *ShopListingApiService) GetListingsByListingIdsExecute(r ApiGetListingsByListingIdsRequest) (*ShopListingsWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListingsWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingsByListingIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingIds == nil {
		return localVarReturnValue, nil, reportError("listingIds is required and must be specified")
	}

	{
		t := *r.listingIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "listing_ids", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "listing_ids", t, "multi")
		}
	}
	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingsByShopRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	state *string
	limit *int32
	offset *int32
	sortOn *string
	sortOrder *string
	includes *[]string
}

// When _updating_ a listing, this value can be either &#x60;active&#x60; or &#x60;inactive&#x60;. Note: Setting a &#x60;draft&#x60; listing to &#x60;active&#x60; will also publish the listing on etsy.com and requires that the listing have an image set. Setting a &#x60;sold_out&#x60; listing to active will update the quantity to 1 and renew the listing on etsy.com.
func (r ApiGetListingsByShopRequest) State(state string) ApiGetListingsByShopRequest {
	r.state = &state
	return r
}

// The maximum number of results to return.
func (r ApiGetListingsByShopRequest) Limit(limit int32) ApiGetListingsByShopRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiGetListingsByShopRequest) Offset(offset int32) ApiGetListingsByShopRequest {
	r.offset = &offset
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ApiGetListingsByShopRequest) SortOn(sortOn string) ApiGetListingsByShopRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ApiGetListingsByShopRequest) SortOrder(sortOrder string) ApiGetListingsByShopRequest {
	r.sortOrder = &sortOrder
	return r
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ApiGetListingsByShopRequest) Includes(includes []string) ApiGetListingsByShopRequest {
	r.includes = &includes
	return r
}

func (r ApiGetListingsByShopRequest) Execute() (*ShopListingsWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingsByShopExecute(r)
}

/*
GetListingsByShop Method for GetListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Endpoint to list Listings that belong to a Shop. Listings can be filtered using the 'state' param.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetListingsByShopRequest
*/
func (a *ShopListingApiService) GetListingsByShop(ctx context.Context, shopId int32) ApiGetListingsByShopRequest {
	return ApiGetListingsByShopRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListingsWithAssociations
func (a *ShopListingApiService) GetListingsByShopExecute(r ApiGetListingsByShopRequest) (*ShopListingsWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListingsWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	}
	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingsByShopReceiptRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	receiptId int32
	shopId int32
	limit *int32
	offset *int32
}

// The maximum number of results to return.
func (r ApiGetListingsByShopReceiptRequest) Limit(limit int32) ApiGetListingsByShopReceiptRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiGetListingsByShopReceiptRequest) Offset(offset int32) ApiGetListingsByShopReceiptRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListingsByShopReceiptRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopReceiptExecute(r)
}

/*
GetListingsByShopReceipt Method for GetListingsByShopReceipt

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Gets all listings associated with a receipt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId The numeric ID for the [receipt](/documentation/reference#tag/Shop-Receipt) associated to this transaction.
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetListingsByShopReceiptRequest
*/
func (a *ShopListingApiService) GetListingsByShopReceipt(ctx context.Context, receiptId int32, shopId int32) ApiGetListingsByShopReceiptRequest {
	return ApiGetListingsByShopReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) GetListingsByShopReceiptExecute(r ApiGetListingsByShopReceiptRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingsByShopReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/receipts/{receipt_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.receiptId < 1 {
		return localVarReturnValue, nil, reportError("receiptId must be greater than 1")
	}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingsByShopReturnPolicyRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	returnPolicyId int32
	shopId int32
}

func (r ApiGetListingsByShopReturnPolicyRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopReturnPolicyExecute(r)
}

/*
GetListingsByShopReturnPolicy Method for GetListingsByShopReturnPolicy

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Gets all listings associated with a Return Policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param returnPolicyId The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies).
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetListingsByShopReturnPolicyRequest
*/
func (a *ShopListingApiService) GetListingsByShopReturnPolicy(ctx context.Context, returnPolicyId int32, shopId int32) ApiGetListingsByShopReturnPolicyRequest {
	return ApiGetListingsByShopReturnPolicyRequest{
		ApiService: a,
		ctx: ctx,
		returnPolicyId: returnPolicyId,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) GetListingsByShopReturnPolicyExecute(r ApiGetListingsByShopReturnPolicyRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingsByShopReturnPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/policies/return/{return_policy_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"return_policy_id"+"}", url.PathEscape(parameterValueToString(r.returnPolicyId, "returnPolicyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnPolicyId < 1 {
		return localVarReturnValue, nil, reportError("returnPolicyId must be greater than 1")
	}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingsByShopSectionIdRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	shopSectionIds *[]int32
	limit *int32
	offset *int32
	sortOn *string
	sortOrder *string
}

// A list of numeric IDS for all sections in a specific Etsy shop.
func (r ApiGetListingsByShopSectionIdRequest) ShopSectionIds(shopSectionIds []int32) ApiGetListingsByShopSectionIdRequest {
	r.shopSectionIds = &shopSectionIds
	return r
}

// The maximum number of results to return.
func (r ApiGetListingsByShopSectionIdRequest) Limit(limit int32) ApiGetListingsByShopSectionIdRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ApiGetListingsByShopSectionIdRequest) Offset(offset int32) ApiGetListingsByShopSectionIdRequest {
	r.offset = &offset
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ApiGetListingsByShopSectionIdRequest) SortOn(sortOn string) ApiGetListingsByShopSectionIdRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ApiGetListingsByShopSectionIdRequest) SortOrder(sortOrder string) ApiGetListingsByShopSectionIdRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetListingsByShopSectionIdRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopSectionIdExecute(r)
}

/*
GetListingsByShopSectionId Method for GetListingsByShopSectionId

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves all the listings from the section of a specific shop.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @return ApiGetListingsByShopSectionIdRequest
*/
func (a *ShopListingApiService) GetListingsByShopSectionId(ctx context.Context, shopId int32) ApiGetListingsByShopSectionIdRequest {
	return ApiGetListingsByShopSectionIdRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return ShopListings
func (a *ShopListingApiService) GetListingsByShopSectionIdExecute(r ApiGetListingsByShopSectionIdRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.GetListingsByShopSectionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shop-sections/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shopSectionIds == nil {
		return localVarReturnValue, nil, reportError("shopSectionIds is required and must be specified")
	}

	{
		t := *r.shopSectionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shop_section_ids", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shop_section_ids", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateListingRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	listingId int32
	imageIds *[]int32
	title *string
	description *string
	materials *[]string
	shouldAutoRenew *bool
	shippingProfileId *int32
	returnPolicyId *int32
	shopSectionId *int32
	itemWeight *float32
	itemLength *float32
	itemWidth *float32
	itemHeight *float32
	itemWeightUnit *string
	itemDimensionsUnit *string
	isTaxable *bool
	taxonomyId *int32
	tags *[]string
	whoMade *string
	whenMade *string
	featuredRank *int32
	isPersonalizable *bool
	personalizationIsRequired *bool
	personalizationCharCountMax *int32
	personalizationInstructions *string
	state *string
	isSupply *bool
	productionPartnerIds *[]int32
	type_ *string
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ApiUpdateListingRequest) ImageIds(imageIds []int32) ApiUpdateListingRequest {
	r.imageIds = &imageIds
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ApiUpdateListingRequest) Title(title string) ApiUpdateListingRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ApiUpdateListingRequest) Description(description string) ApiUpdateListingRequest {
	r.description = &description
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ApiUpdateListingRequest) Materials(materials []string) ApiUpdateListingRequest {
	r.materials = &materials
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ApiUpdateListingRequest) ShouldAutoRenew(shouldAutoRenew bool) ApiUpdateListingRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ApiUpdateListingRequest) ShippingProfileId(shippingProfileId int32) ApiUpdateListingRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies). Required for active physical listings. This requirement does not apply to listings of EU-based shops.
func (r ApiUpdateListingRequest) ReturnPolicyId(returnPolicyId int32) ApiUpdateListingRequest {
	r.returnPolicyId = &returnPolicyId
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ApiUpdateListingRequest) ShopSectionId(shopSectionId int32) ApiUpdateListingRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingRequest) ItemWeight(itemWeight float32) ApiUpdateListingRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingRequest) ItemLength(itemLength float32) ApiUpdateListingRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingRequest) ItemWidth(itemWidth float32) ApiUpdateListingRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingRequest) ItemHeight(itemHeight float32) ApiUpdateListingRequest {
	r.itemHeight = &itemHeight
	return r
}

// A string defining the units used to measure the weight of the product. Default value is null.
func (r ApiUpdateListingRequest) ItemWeightUnit(itemWeightUnit string) ApiUpdateListingRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

// A string defining the units used to measure the dimensions of the product. Default value is null.
func (r ApiUpdateListingRequest) ItemDimensionsUnit(itemDimensionsUnit string) ApiUpdateListingRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ApiUpdateListingRequest) IsTaxable(isTaxable bool) ApiUpdateListingRequest {
	r.isTaxable = &isTaxable
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ApiUpdateListingRequest) TaxonomyId(taxonomyId int32) ApiUpdateListingRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ApiUpdateListingRequest) Tags(tags []string) ApiUpdateListingRequest {
	r.tags = &tags
	return r
}

// An enumerated string indicating who made the product. Helps buyers locate the listing under the Handmade heading. Requires &#39;is_supply&#39; and &#39;when_made&#39;.
func (r ApiUpdateListingRequest) WhoMade(whoMade string) ApiUpdateListingRequest {
	r.whoMade = &whoMade
	return r
}

// An enumerated string for the era in which the maker made the product in this listing. Helps buyers locate the listing under the Vintage heading. Requires &#39;is_supply&#39; and &#39;who_made&#39;.
func (r ApiUpdateListingRequest) WhenMade(whenMade string) ApiUpdateListingRequest {
	r.whenMade = &whenMade
	return r
}

// The positive non-zero numeric position in the featured listings of the shop, with rank 1 listings appearing in the left-most position in featured listing on a shop’s home page.
func (r ApiUpdateListingRequest) FeaturedRank(featuredRank int32) ApiUpdateListingRequest {
	r.featuredRank = &featuredRank
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ApiUpdateListingRequest) IsPersonalizable(isPersonalizable bool) ApiUpdateListingRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingRequest) PersonalizationIsRequired(personalizationIsRequired bool) ApiUpdateListingRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingRequest) PersonalizationCharCountMax(personalizationCharCountMax int32) ApiUpdateListingRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingRequest) PersonalizationInstructions(personalizationInstructions string) ApiUpdateListingRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

// When _updating_ a listing, this value can be either &#x60;active&#x60; or &#x60;inactive&#x60;. Note: Setting a &#x60;draft&#x60; listing to &#x60;active&#x60; will also publish the listing on etsy.com and requires that the listing have an image set. Setting a &#x60;sold_out&#x60; listing to active will update the quantity to 1 and renew the listing on etsy.com.
func (r ApiUpdateListingRequest) State(state string) ApiUpdateListingRequest {
	r.state = &state
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ApiUpdateListingRequest) IsSupply(isSupply bool) ApiUpdateListingRequest {
	r.isSupply = &isSupply
	return r
}

// An array of unique IDs of production partner ids.
func (r ApiUpdateListingRequest) ProductionPartnerIds(productionPartnerIds []int32) ApiUpdateListingRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

// An enumerated type string that indicates whether the listing is physical or a digital download.
func (r ApiUpdateListingRequest) Type_(type_ string) ApiUpdateListingRequest {
	r.type_ = &type_
	return r
}

func (r ApiUpdateListingRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.UpdateListingExecute(r)
}

/*
UpdateListing Method for UpdateListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. Note that this is a PATCH method type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @return ApiUpdateListingRequest
*/
func (a *ShopListingApiService) UpdateListing(ctx context.Context, shopId int32, listingId int32) ApiUpdateListingRequest {
	return ApiUpdateListingRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		listingId: listingId,
	}
}

// Execute executes the request
//  @return ShopListing
func (a *ShopListingApiService) UpdateListingExecute(r ApiUpdateListingRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.UpdateListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "csv")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "")
	}
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "")
	}
	if r.returnPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "return_policy_id", r.returnPolicyId, "")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "csv")
	}
	if r.whoMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "")
	}
	if r.whenMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "")
	}
	if r.featuredRank != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "featured_rank", r.featuredRank, "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "state", r.state, "")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "csv")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateListingDeprecatedRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	listingId int32
	imageIds *[]int32
	title *string
	description *string
	materials *[]string
	shouldAutoRenew *bool
	shippingProfileId *int32
	shopSectionId *int32
	itemWeight *float32
	itemLength *float32
	itemWidth *float32
	itemHeight *float32
	itemWeightUnit *string
	itemDimensionsUnit *string
	isTaxable *bool
	taxonomyId *int32
	tags *[]string
	whoMade *string
	whenMade *string
	featuredRank *int32
	isPersonalizable *bool
	personalizationIsRequired *bool
	personalizationCharCountMax *int32
	personalizationInstructions *string
	state *string
	isSupply *bool
	productionPartnerIds *[]int32
	type_ *string
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ApiUpdateListingDeprecatedRequest) ImageIds(imageIds []int32) ApiUpdateListingDeprecatedRequest {
	r.imageIds = &imageIds
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ApiUpdateListingDeprecatedRequest) Title(title string) ApiUpdateListingDeprecatedRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ApiUpdateListingDeprecatedRequest) Description(description string) ApiUpdateListingDeprecatedRequest {
	r.description = &description
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ApiUpdateListingDeprecatedRequest) Materials(materials []string) ApiUpdateListingDeprecatedRequest {
	r.materials = &materials
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ApiUpdateListingDeprecatedRequest) ShouldAutoRenew(shouldAutoRenew bool) ApiUpdateListingDeprecatedRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ApiUpdateListingDeprecatedRequest) ShippingProfileId(shippingProfileId int32) ApiUpdateListingDeprecatedRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ApiUpdateListingDeprecatedRequest) ShopSectionId(shopSectionId int32) ApiUpdateListingDeprecatedRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingDeprecatedRequest) ItemWeight(itemWeight float32) ApiUpdateListingDeprecatedRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingDeprecatedRequest) ItemLength(itemLength float32) ApiUpdateListingDeprecatedRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingDeprecatedRequest) ItemWidth(itemWidth float32) ApiUpdateListingDeprecatedRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ApiUpdateListingDeprecatedRequest) ItemHeight(itemHeight float32) ApiUpdateListingDeprecatedRequest {
	r.itemHeight = &itemHeight
	return r
}

// A string defining the units used to measure the weight of the product. Default value is null.
func (r ApiUpdateListingDeprecatedRequest) ItemWeightUnit(itemWeightUnit string) ApiUpdateListingDeprecatedRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

// A string defining the units used to measure the dimensions of the product. Default value is null.
func (r ApiUpdateListingDeprecatedRequest) ItemDimensionsUnit(itemDimensionsUnit string) ApiUpdateListingDeprecatedRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ApiUpdateListingDeprecatedRequest) IsTaxable(isTaxable bool) ApiUpdateListingDeprecatedRequest {
	r.isTaxable = &isTaxable
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ApiUpdateListingDeprecatedRequest) TaxonomyId(taxonomyId int32) ApiUpdateListingDeprecatedRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ApiUpdateListingDeprecatedRequest) Tags(tags []string) ApiUpdateListingDeprecatedRequest {
	r.tags = &tags
	return r
}

// An enumerated string indicating who made the product. Helps buyers locate the listing under the Handmade heading. Requires &#39;is_supply&#39; and &#39;when_made&#39;.
func (r ApiUpdateListingDeprecatedRequest) WhoMade(whoMade string) ApiUpdateListingDeprecatedRequest {
	r.whoMade = &whoMade
	return r
}

// An enumerated string for the era in which the maker made the product in this listing. Helps buyers locate the listing under the Vintage heading. Requires &#39;is_supply&#39; and &#39;who_made&#39;.
func (r ApiUpdateListingDeprecatedRequest) WhenMade(whenMade string) ApiUpdateListingDeprecatedRequest {
	r.whenMade = &whenMade
	return r
}

// The positive non-zero numeric position in the featured listings of the shop, with rank 1 listings appearing in the left-most position in featured listing on a shop’s home page.
func (r ApiUpdateListingDeprecatedRequest) FeaturedRank(featuredRank int32) ApiUpdateListingDeprecatedRequest {
	r.featuredRank = &featuredRank
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ApiUpdateListingDeprecatedRequest) IsPersonalizable(isPersonalizable bool) ApiUpdateListingDeprecatedRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingDeprecatedRequest) PersonalizationIsRequired(personalizationIsRequired bool) ApiUpdateListingDeprecatedRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingDeprecatedRequest) PersonalizationCharCountMax(personalizationCharCountMax int32) ApiUpdateListingDeprecatedRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ApiUpdateListingDeprecatedRequest) PersonalizationInstructions(personalizationInstructions string) ApiUpdateListingDeprecatedRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

// When _updating_ a listing, this value can be either &#x60;active&#x60; or &#x60;inactive&#x60;. Note: Setting a &#x60;draft&#x60; listing to &#x60;active&#x60; will also publish the listing on etsy.com and requires that the listing have an image set. Setting a &#x60;sold_out&#x60; listing to active will update the quantity to 1 and renew the listing on etsy.com.
func (r ApiUpdateListingDeprecatedRequest) State(state string) ApiUpdateListingDeprecatedRequest {
	r.state = &state
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ApiUpdateListingDeprecatedRequest) IsSupply(isSupply bool) ApiUpdateListingDeprecatedRequest {
	r.isSupply = &isSupply
	return r
}

// An array of unique IDs of production partner ids.
func (r ApiUpdateListingDeprecatedRequest) ProductionPartnerIds(productionPartnerIds []int32) ApiUpdateListingDeprecatedRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

// An enumerated type string that indicates whether the listing is physical or a digital download.
func (r ApiUpdateListingDeprecatedRequest) Type_(type_ string) ApiUpdateListingDeprecatedRequest {
	r.type_ = &type_
	return r
}

func (r ApiUpdateListingDeprecatedRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.UpdateListingDeprecatedExecute(r)
}

/*
UpdateListingDeprecated Method for UpdateListingDeprecated

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. This endpoint will be removed in the near future in favor of `updateListing` PATCH version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @return ApiUpdateListingDeprecatedRequest
*/
func (a *ShopListingApiService) UpdateListingDeprecated(ctx context.Context, shopId int32, listingId int32) ApiUpdateListingDeprecatedRequest {
	return ApiUpdateListingDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		listingId: listingId,
	}
}

// Execute executes the request
//  @return ShopListing
func (a *ShopListingApiService) UpdateListingDeprecatedExecute(r ApiUpdateListingDeprecatedRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.UpdateListingDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "csv")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "")
	}
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "csv")
	}
	if r.whoMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "")
	}
	if r.whenMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "")
	}
	if r.featuredRank != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "featured_rank", r.featuredRank, "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "state", r.state, "")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "csv")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateListingPropertyRequest struct {
	ctx context.Context
	ApiService *ShopListingApiService
	shopId int32
	listingId int32
	propertyId int32
	valueIds *[]int32
	values *[]string
	scaleId *int32
}

// An array of unique IDs of multiple Etsy [listing property](/documentation/reference#operation/getListingProperties) values. For example, if your listing offers different sizes of a product, then the value ID list contains value IDs for each size.
func (r ApiUpdateListingPropertyRequest) ValueIds(valueIds []int32) ApiUpdateListingPropertyRequest {
	r.valueIds = &valueIds
	return r
}

// An array of value strings for multiple Etsy [listing property](/documentation/reference#operation/getListingProperties) values. For example, if your listing offers different colored products, then the values array contains the color strings for each color. Note: parenthesis characters (&#x60;(&#x60; and &#x60;)&#x60;) are not allowed.
func (r ApiUpdateListingPropertyRequest) Values(values []string) ApiUpdateListingPropertyRequest {
	r.values = &values
	return r
}

// The numeric ID of a single Etsy.com measurement scale. For example, for shoe size, there are three &#x60;scale_id&#x60;s available - &#x60;UK&#x60;, &#x60;US/Canada&#x60;, and &#x60;EU&#x60;, where &#x60;US/Canada&#x60; has &#x60;scale_id&#x60; 19.
func (r ApiUpdateListingPropertyRequest) ScaleId(scaleId int32) ApiUpdateListingPropertyRequest {
	r.scaleId = &scaleId
	return r
}

func (r ApiUpdateListingPropertyRequest) Execute() (*ListingPropertyValue, *http.Response, error) {
	return r.ApiService.UpdateListingPropertyExecute(r)
}

/*
UpdateListingProperty Method for UpdateListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notification-03 wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates or populates the properties list defining product offerings for a listing. Each offering requires both a `value` and a `value_id` that are valid for a `scale_id` assigned to the listing or that you assign to the listing with this request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shopId The unique positive non-zero numeric ID for an Etsy Shop.
 @param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
 @param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
 @return ApiUpdateListingPropertyRequest
*/
func (a *ShopListingApiService) UpdateListingProperty(ctx context.Context, shopId int32, listingId int32, propertyId int32) ApiUpdateListingPropertyRequest {
	return ApiUpdateListingPropertyRequest{
		ApiService: a,
		ctx: ctx,
		shopId: shopId,
		listingId: listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ListingPropertyValue
func (a *ShopListingApiService) UpdateListingPropertyExecute(r ApiUpdateListingPropertyRequest) (*ListingPropertyValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingPropertyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingApiService.UpdateListingProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return localVarReturnValue, nil, reportError("propertyId must be greater than 1")
	}
	if r.valueIds == nil {
		return localVarReturnValue, nil, reportError("valueIds is required and must be specified")
	}
	if r.values == nil {
		return localVarReturnValue, nil, reportError("values is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "value_ids", r.valueIds, "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "values", r.values, "csv")
	if r.scaleId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "scale_id", r.scaleId, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
